#!/usr/bin/python3
import os, sys, csv

if len(sys.argv) != 3:
    print (" Usage: %s ops.csv" % (sys.argv[0]))
    print ("\twhere ops.csv is a csv file with the format")
    print ("\topcode,mnemonic,addressing mode,bytes,cycles,flags")
    print ("\tIf ran standalone add . as third argument.")
    sys.exit(1)

file = sys.argv[2] + '/' + 'disassembler.h'
sys.stdout = open(file,'wt')

print(r"""/*
* file generated by genDisassembler.py, DO NOT EDIT,
* changes will be overwritten on compile time
*/
#ifndef SRC_DISASSEMBLER_H
#define SRC_DISASSEMBLER_H
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>

namespace tools{
class Disassembler {
private:
    static int disassemble_(std::string &buffer, int pc)
    {
		int tmp = pc;
		int tmp2 = pc + 1;
		int tmp3 = pc + 2;
		int tmp4 = pc + 3;
		int tmp5 = pc + 4;
		int tmp6 = pc + 5;
		
		unsigned int x;   
    	std::stringstream ss;
    	ss << std::hex << buffer[tmp] << buffer[tmp2];
   		ss >> x;
		ss.clear();

        int count;
		//std::cout << "\npc:  "<< pc;
		//std::cout << "\nstr: "<< ss.str();
		//std::cout << "\nhex: " << x;

		switch (x) {
""", end='')

opdict = {}

with open(sys.argv[1]) as csvfile:
    reader = csv.reader(csvfile, delimiter=',')
    next(reader) #skip first line
    for row in reader:
        if len(row) == 6:
            opcode=int(row[0],16)
            opdict[opcode] = [row[1], row[2], row[3], row[4], row[5]]

opnums = opdict.keys()
sorted(opnums)

for op in opnums:
    #opcode/mnemonic/addressing mode/bytes/cycles/flags
    #disassemble depends on addressing mode
    addressingmode = opdict[op][1]


    if addressingmode == "IMP":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "           " << "%s" << std::endl; break;' % (op, opdict[op][0]))
    elif addressingmode == "ACC":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "           " << "%s A" << std::endl; break;' % (op, opdict[op][0]))

    elif addressingmode == "IMM":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp3] << buffer[tmp4] << "       %s #$" << buffer[tmp3] << buffer[tmp4] << std::endl; count = 4; break;' % (op, opdict[op][0]))
    elif addressingmode == "ZP":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp3] << buffer[tmp4] << "       %s $" << buffer[tmp3] << buffer[tmp4] << std::endl; count = 4; break;' % (op, opdict[op][0]))

    elif addressingmode == "INDX":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp3] << buffer[tmp4] << "       %s ($" << buffer[tmp3] << buffer[tmp4] << ",X)" << std::endl; count = 4; break;' % (op, opdict[op][0]))
    elif addressingmode == "INDY":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp3] << buffer[tmp4] << "       %s ($" << buffer[tmp3] << buffer[tmp4] << "),Y" << std::endl; count = 4; break;' % (op, opdict[op][0]))
    elif addressingmode == "ZPX":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp3] << buffer[tmp4] << "       %s ($" << buffer[tmp3] << buffer[tmp4] << ",X" << std::endl; count = 4; break;' % (op, opdict[op][0]))
    elif addressingmode == "ZPY":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp3] << buffer[tmp4] << "       %s ($" << buffer[tmp3] << buffer[tmp4] << ",Y" << std::endl; count = 4; break;' % (op, opdict[op][0]))
    elif addressingmode == "REL":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp3] << buffer[tmp4] << "       %s ($" << buffer[tmp3] << buffer[tmp4] << std::endl; count = 4; break;' % (op, opdict[op][0]))

    elif addressingmode == "IND":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp5] << buffer[tmp6]  << "  " << buffer[tmp3] << buffer[tmp4] << "   %s ($"  << buffer[tmp5] << buffer[tmp6] << buffer[tmp3] << buffer[tmp4] << ")" << std::endl; count = 6; break;' % (op, opdict[op][0]))
    elif addressingmode == "ABS":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp5] << buffer[tmp6]  << "  " << buffer[tmp3] << buffer[tmp4] << "   %s $"  << buffer[tmp5] << buffer[tmp6] << buffer[tmp3] << buffer[tmp4] << std::endl; count = 6; break;' % (op, opdict[op][0]))
    elif addressingmode == "ABSX":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp5] << buffer[tmp6]  << "  " << buffer[tmp3] << buffer[tmp4] << "   %s $"  << buffer[tmp5] << buffer[tmp6] << buffer[tmp3] << buffer[tmp4] << ",X" << std::endl; count = 6; break;' % (op, opdict[op][0]))
    elif addressingmode == "ABSY":
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "  " << buffer[tmp5] << buffer[tmp6]  << "  " << buffer[tmp3] << buffer[tmp4] << "   %s $"  << buffer[tmp5] << buffer[tmp6] << buffer[tmp3] << buffer[tmp4] << ",Y"  << std::endl; count = 6; break;' % (op, opdict[op][0]))

    else:
        print ('\t\tcase 0x%02x: std::cout << buffer[tmp] << buffer[tmp2] << "           " << "UNKNOWN" << std::endl; break;' % (op), end='')

print(r"""
        default:
            std::cout << "???" << std::endl;;
			break;
        }
        return count;
    }

public:    
    int disassemble(std::string filename)
    {
        std::string buffer;

		std::ifstream in(filename);
 
		// If we couldn't open the output file stream for reading
		if (!in) {
			std::cerr << filename << " could not be opened for reading!" << std::endl;
			return 1;
		}
		
		while (in){ // While there's still stuff left to read
			in >> buffer;
		}
		in.close();

        unsigned pc = 0;
		//std::cout << "buffer: " << buffer << "\n";
        std::cout << "  Hexdump    Disassembly" << "\n";
		std::cout << "------------------------" << "\n";
		while (pc < buffer.size()) {
            pc += disassemble_(buffer, pc);
        }
		return 0;
    }
};
} //namespace tools
#endif //SRC_DISASSEMBLER_H
""")